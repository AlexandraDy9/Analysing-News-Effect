{
  "_args": [
    [
      {
        "raw": "ml-matrix@^6.1.2",
        "scope": null,
        "escapedName": "ml-matrix",
        "name": "ml-matrix",
        "rawSpec": "^6.1.2",
        "spec": ">=6.1.2 <7.0.0",
        "type": "range"
      },
      "C:\\Users\\nica_\\Desktop\\nodejs\\node_modules\\ml-regression"
    ]
  ],
  "_from": "ml-matrix@^6.1.2",
  "_hasShrinkwrap": false,
  "_id": "ml-matrix@6.4.1",
  "_location": "/ml-matrix",
  "_nodeVersion": "12.11.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/ml-matrix_6.4.1_1569848363795_0.8259025054347047"
  },
  "_npmUser": {
    "name": "targos",
    "email": "targos+npm@protonmail.com"
  },
  "_npmVersion": "6.11.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "ml-matrix@^6.1.2",
    "scope": null,
    "escapedName": "ml-matrix",
    "name": "ml-matrix",
    "rawSpec": "^6.1.2",
    "spec": ">=6.1.2 <7.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/ml-kernel",
    "/ml-regression",
    "/ml-regression-multivariate-linear",
    "/ml-regression-polynomial",
    "/ml-regression-robust-polynomial"
  ],
  "_resolved": "https://registry.npmjs.org/ml-matrix/-/ml-matrix-6.4.1.tgz",
  "_shasum": "388082df1584b34ffe14e26115dbc5f0f3312ff1",
  "_shrinkwrap": null,
  "_spec": "ml-matrix@^6.1.2",
  "_where": "C:\\Users\\nica_\\Desktop\\nodejs\\node_modules\\ml-regression",
  "author": {
    "name": "MichaÃ«l Zasso"
  },
  "bugs": {
    "url": "https://github.com/mljs/matrix/issues"
  },
  "dependencies": {
    "ml-array-rescale": "^1.2.2"
  },
  "description": "Matrix manipulation and computation library",
  "devDependencies": {
    "@babel/plugin-transform-modules-commonjs": "^7.6.0",
    "benchmark": "^2.1.4",
    "csv-parse": "^4.4.7",
    "eslint": "^6.5.0",
    "eslint-config-cheminfo": "^2.0.3",
    "eslint-plugin-import": "^2.18.2",
    "eslint-plugin-jest": "^22.17.0",
    "eslint-plugin-prettier": "^3.1.1",
    "jest": "^24.9.0",
    "jest-matcher-deep-close-to": "^1.3.0",
    "mathjs": "^6.2.2",
    "ml-dataset-iris": "^1.1.1",
    "numeric": "^1.2.6",
    "prettier": "^1.18.2",
    "pretty-hrtime": "^1.0.3",
    "rollup": "^1.22.0",
    "rollup-plugin-commonjs": "^10.1.0",
    "rollup-plugin-node-resolve": "^5.2.0",
    "rollup-plugin-terser": "^5.1.2",
    "typedoc": "^0.15.0"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-YZ6lLRhk80B2zJSC0bKocnHbpxCdXFKWb6A7QTDztf5ob2qL1g/5AYNAuDtCQgbZtW1wwFZbjXbDgk/UdiO3Uw==",
    "shasum": "388082df1584b34ffe14e26115dbc5f0f3312ff1",
    "tarball": "https://registry.npmjs.org/ml-matrix/-/ml-matrix-6.4.1.tgz",
    "fileCount": 41,
    "unpackedSize": 379555,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdkfwsCRA9TVsSAnZWagAAc4YQAIBcpE0FzVO8Eefr9aN/\ntYo3FhVGzAPTs8Gw5FKKfaPTr6V6KFWMHI80oHUpcDA4OJdvYtaC9BceerSq\nSrPpZitupDTpFHfojwoY8OklNJHUouxAJL9Syxk+AQniPLNEFYv8iLBsxEk8\nVut2Mt/9rvErswoeeFMjn5ks7fZrJByczN8AvSEYNjRlEkQIcmn9CizUZnFH\nG62BNfY0BKBGbeGvdyy1xel4rzQ3j8muIowvxQk+j2VSIK5Piz3jIXP8qq4z\nj2codM/rsRmY+rnKo4Yx7v6W5m4Q7m95xO01CSNnAr0qt2msxjExHCj5gzno\ng75aUJJZMTWzA23cz/j4rL8NXgknNfE/XHv2/5LAZjcbPX/WwZyHaSZIURtv\nKgrBP1HCjG33yjM3MuTgMLJqhSxWGf+FFDjSLpSEcRwtuFUOD1LeXraHt2Tc\nvZlfmx0cdCjYmh1fb8X24U266+1E0we9dU2JTOYGfux5YOb0mz8u7RAPcRJ6\nNinrpxgbwqO1Uj1rMSSx2AWUEdC4inarFMg072nI8iWBRyld88wFrO04Qy1d\nvSGIqGVWaS7PBJ6JNnH2rCTgtHkBj98nHiVn6V0xhfeXMoGht6zKFI/o8fLn\n8TNto6htbCAlgi9FGB8Qkj2JBTPvSDRc3cAt0Ms48wBHE7eHWUTaUijBOjnE\nSJLd\r\n=U4DQ\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "matrix.d.ts",
    "matrix.js",
    "matrix.umd.js",
    "src"
  ],
  "gitHead": "ab356186b23d14970cbe200fba275c0ca763c357",
  "homepage": "https://github.com/mljs/matrix",
  "jest": {
    "testEnvironment": "node"
  },
  "jsdelivr": "matrix.umd.js",
  "keywords": [
    "matrix",
    "decomposition",
    "SVD",
    "singular",
    "value",
    "EVD",
    "eigenvalue",
    "LU",
    "Qr",
    "Cholesky",
    "data",
    "mining",
    "datamining",
    "machine",
    "learning"
  ],
  "license": "MIT",
  "main": "matrix.js",
  "maintainers": [
    {
      "name": "andcastillo",
      "email": "andcastillo@gmail.com"
    },
    {
      "name": "jeffersonh44",
      "email": "swrt_9950@hotmail.com"
    },
    {
      "name": "lpatiny",
      "email": "lpatiny@gmail.com"
    },
    {
      "name": "maasencioh",
      "email": "maasencioh@gmail.com"
    },
    {
      "name": "ml-bot",
      "email": "admin@cheminfo.org"
    },
    {
      "name": "stropitek",
      "email": "kostro.d@gmail.com"
    },
    {
      "name": "targos",
      "email": "targos@live.com"
    }
  ],
  "module": "src/index.js",
  "name": "ml-matrix",
  "optionalDependencies": {},
  "readme": "# ml-matrix\n\n[![NPM version][npm-image]][npm-url]\n[![build status][travis-image]][travis-url]\n[![Test coverage][codecov-image]][codecov-url]\n[![npm download][download-image]][download-url]\n\nMatrix manipulation and computation library.\n\n## Installation\n\n`$ npm install ml-matrix`\n\n## Usage\n\n### As an ES module\n\n```js\nimport { Matrix } from 'ml-matrix';\n\nconst matrix = Matrix.ones(5, 5);\n```\n\n### As a CommonJS module\n\n```js\nconst { Matrix } = require('ml-matrix');\n\nconst matrix = Matrix.ones(5, 5);\n```\n\n## [API Documentation](https://mljs.github.io/matrix/globals.html)\n\n## Examples\n\n### Standard operations\n\n```js\nconst { Matrix } = require('ml-matrix');\n\nvar A = new Matrix([[1, 1], [2, 2]]);\nvar B = new Matrix([[3, 3], [1, 1]]);\nvar C = new Matrix([[3, 3], [1, 1]]);\n\n// ============================\n// Operations with the matrix :\n// =============================\n\n// operations :\nconst addition = Matrix.add(A, B); // addition = Matrix [[4, 4], [3, 3], rows: 2, columns: 2]\nconst substraction = Matrix.sub(A, B); // substraction = Matrix [[-2, -2], [1, 1], rows: 2, columns: 2]\nconst multiplication = A.mmul(B); // multiplication = Matrix [[4, 4], [8, 8], rows: 2, columns: 2]\nconst mulByNumber = Matrix.mul(A, 10); // mulByNumber = Matrix [[10, 10], [20, 20], rows: 2, columns: 2]\nconst divByNumber = Matrix.div(A, 10); // divByNumber = Matrix [[0.1, 0.1], [0.2, 0.2], rows: 2, columns: 2]\nconst modulo = Matrix.mod(B, 2); // modulo = Matrix [[ 1, 1], [1, 1], rows: 2, columns: 2]\nconst maxMatrix = Matrix.max(A, B); // max = Matrix [[3, 3], [2, 2], rows: 2, columns: 2]\nconst minMatrix = Matrix.min(A, B); // max = Matrix [[1, 1], [1, 1], rows: 2, columns: 2]\n\n// Inplace operations : (consider that Cinit = C before all the operations below)\nC.add(A); // => C = Cinit + A\nC.sub(A); // => C = Cinit\nC.mul(10); // => C = 10 * Cinit\nC.div(10); // => C = Cinit\nC.mod(2); // => C = Cinit % 2\n\n// Standard Math operations : (abs, cos, round, etc.)\nvar A = new Matrix([[1, 1], [-1, -1]]);\nvar expon = Matrix.exp(A); // expon = Matrix [[Math.exp(1), Math.exp(1)], [Math.exp(-1), Math.exp(-1)], rows: 2, columns: 2].\nvar cosinus = Matrix.cos(A); // cosinus = Matrix [[Math.cos(1), Math.cos(1)], [Math.cos(-1), Math.cos(-1)], rows: 2, columns: 2].\nvar absolute = Matrix.abs(A); // expon = absolute [[1, 1], [1, 1], rows: 2, columns: 2].\n// you can use 'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil', 'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p', 'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'\n// Note : you can do it inplace too as A.abs()\n\n// ============================\n// Manipulation of the matrix :\n// =============================\n\nvar numberRows = A.rows; // A has 2 rows\nvar numberCols = A.columns; // A has 2 columns\nvar firstValue = A.get(0, 0); // get(rows, columns)\nvar numberElements = A.size; // 2 * 2 = 4 elements\nvar isRow = A.isRowVector(); // false because A has more that 1 row\nvar isColumn = A.isColumnVector(); // false because A has more that 1 column\nvar isSquare = A.isSquare(); // true, because A is 2 * 2 matrix\nvar isSym = A.isSymmetric(); // false, because A is not symmetric\n// remember : A = Matrix [[1, 1], [-1, -1], rows: 2, columns: 2]\nA.set(1, 0, 10); // A = Matrix [[1, 1], [10, -1], rows: 2, columns: 2]. We have change the second row and the first column\nvar diag = A.diag(); // diag = [1, -1], i.e values in the diagonal.\nvar m = A.mean(); // m = 2.75\nvar product = A.prod(); // product = -10, i.e product of all values of the matrix\nvar norm = A.norm(); // norm = 10.14889156509222, i.e Frobenius norm of the matrix\nvar transpose = A.transpose(); // tranpose = Matrix [[1, 10], [1, -1], rows: 2, columns: 2]\n\n// ============================\n// Instanciation of matrix :\n// =============================\n\nvar z = Matrix.zeros(3, 2); // z = Matrix [[0, 0], [0, 0], [0, 0], rows: 3, columns: 2]\nvar z = Matrix.ones(2, 3); // z = Matrix [[1, 1, 1], [1, 1, 1], rows: 2, columns: 3]\nvar z = Matrix.eye(3, 4); // Matrix [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], rows: 3, columns: 4]. there are 1 only in the diagonal\n```\n\n### Maths\n\n```js\nconst {\n  Matrix,\n  inverse,\n  solve,\n  linearDependencies,\n  QrDecomposition,\n  LuDecomposition,\n  CholeskyDecomposition,\n} = require('ml-matrix');\n\n//===========================\n// inverse and pseudo-inverse\n//===========================\n\nvar A = new Matrix([[2, 3, 5], [4, 1, 6], [1, 3, 0]]);\nvar inverseA = inverse(A);\nvar B = A.mmul(inverseA); // B = A * inverse(A), so B ~= Identity\n\n// if A is singular, you can use SVD :\nvar A = new Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // A is singular, so the standard computation of inverse won't work (you can test if you don't trust me^^)\nvar inverseA = inverse(A, (useSVD = true)); // inverseA is only an approximation of the inverse, by using the Singular Values Decomposition\nvar B = A.mmul(inverseA); // B = A * inverse(A), but inverse(A) is only an approximation, so B doesn't really be identity.\n\n// if you want the pseudo-inverse of a matrix :\nvar A = new Matrix([[1, 2], [3, 4], [5, 6]]);\nvar pseudoInverseA = A.pseudoInverse();\nvar B = A.mmul(pseudoInverseA).mmul(A); // with pseudo inverse, A*pseudo-inverse(A)*A ~= A. It's the case here\n\n//=============\n// Least square\n//=============\n\n// Least square is the following problem : We search x, such as A.x = b (A, x and b are matrix or vectors).\n// Below, how to solve least square with our function\n\n// If A is non singular :\nvar A = new Matrix([[3, 1], [4.25, 1], [5.5, 1], [8, 1]]);\nvar b = Matrix.columnVector([4.5, 4.25, 5.5, 5.5]);\nvar x = solve(A, b);\nvar error = Matrix.sub(b, A.mmul(x)); // The error enables to evaluate the solution x found.\n\n// If A is non singular :\nvar A = new Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\nvar b = Matrix.columnVector([8, 20, 32]);\nvar x = solve(A, b, (useSVD = true)); // there are many solutions. x can be [1, 2, 1].transpose(), or [1.33, 1.33, 1.33].transpose(), etc.\nvar error = Matrix.sub(b, A.mmul(x)); // The error enables to evaluate the solution x found.\n\n//===============\n// Decompositions\n//===============\n\n// QR Decomposition\n\nvar A = new Matrix([[2, 3, 5], [4, 1, 6], [1, 3, 0]]);\nvar QR = new QrDecomposition(A);\nvar Q = QR.orthogonalMatrix;\nvar R = QR.upperTriangularMatrix;\n// So you have the QR decomposition. If you multiply Q by R, you'll see that A = Q.R, with Q orthogonal and R upper triangular\n\n// LU Decomposition\n\nvar A = new Matrix([[2, 3, 5], [4, 1, 6], [1, 3, 0]]);\nvar LU = new LuDecomposition(A);\nvar L = LU.lowerTriangularMatrix;\nvar U = LU.upperTriangularMatrix;\nvar P = LU.pivotPermutationVector;\n// So you have the LU decomposition. P includes the permutation of the matrix. Here P = [1, 2, 0], i.e the first row of LU is the second row of A, the second row of LU is the third row of A and the third row of LU is the first row of A.\n\n// Cholesky Decomposition\n\nvar A = new Matrix([[2, 3, 5], [4, 1, 6], [1, 3, 0]]);\nvar cholesky = new CholeskyDecomposition(A);\nvar L = cholesky.lowerTriangularMatrix;\n\n// Eigenvalues & eigenvectors\n\nvar A = new Matrix([[2, 3, 5], [4, 1, 6], [1, 3, 0]]);\nvar e = new EigenvalueDecomposition(A);\nvar real = e.realEigenvalues;\nvar imaginary = e.imaginaryEigenvalues;\nvar vectors = e.eigenvectorMatrix;\n\n//=======\n// Others\n//=======\n\n// Linear dependencies\nvar A = new Matrix([\n  [2, 0, 0, 1],\n  [0, 1, 6, 0],\n  [0, 3, 0, 1],\n  [0, 0, 1, 0],\n  [0, 1, 2, 0],\n]);\nvar dependencies = linearDependencies(A); // dependencies is a matrix with the dependencies of the rows. When we look row by row, we see that the first row is [0, 0, 0, 0, 0], so it means that the first row is independent, and the second row is [ 0, 0, 0, 4, 1 ], i.e the second row = 4 times the 4th row + the 5th row.\n```\n\n## License\n\n[MIT](./LICENSE)\n\n[npm-image]: https://img.shields.io/npm/v/ml-matrix.svg?style=flat-square\n[npm-url]: https://npmjs.org/package/ml-matrix\n[travis-image]: https://img.shields.io/travis/mljs/matrix/master.svg?style=flat-square\n[travis-url]: https://travis-ci.org/mljs/matrix\n[codecov-image]: https://img.shields.io/codecov/c/github/mljs/matrix.svg?style=flat-square\n[codecov-url]: https://codecov.io/github/mljs/matrix\n[download-image]: https://img.shields.io/npm/dm/ml-matrix.svg?style=flat-square\n[download-url]: https://npmjs.org/package/ml-matrix\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mljs/matrix.git"
  },
  "scripts": {
    "build-docs": "typedoc --out docs --name \"ml-matrix\" --mode file --includeDeclarations --excludeExternals --hideGenerator --excludePrivate --moduleResolution node matrix.d.ts",
    "compile": "rollup -c",
    "eslint": "eslint benchmark src testUtils.js",
    "eslint-fix": "npm run eslint -- --fix",
    "prepublishOnly": "npm run compile",
    "test": "npm run test-coverage && npm run eslint",
    "test-coverage": "jest --coverage",
    "test-only": "jest"
  },
  "sideEffects": false,
  "types": "matrix.d.ts",
  "unpkg": "matrix.umd.js",
  "version": "6.4.1"
}
